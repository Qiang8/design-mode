##装饰者模式<br>
####装饰模式<br>
动态地给一个对象增加一些额外的职责。就扩张功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。<br>
装饰模式，可以这么理解。就是给一个类增加行为。比如人类，是父类。男人类，和女人类是子类。如果使用继承就多了两个类，但是用装饰模式，我就直接将人类，装饰成男人类，或女人类，不用进行继承。直接就降低了类于类之间的耦合。<br>
##UML图
![](https://img-blog.csdn.net/20180910223452547?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzA5NDY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
<br>
##角色
Component(抽象构建)：它是具体构建类和抽象装饰类的父类。声明具体构建类的业务方法，它可以使客户端同等的对待被装饰类修饰过的类和没被修饰过的类。实现客户端的透明操作。

ConcreteComponent(具体构件类):它实现了抽象构建类的业务方法，装饰类会给它增加额外的方法。

Decorator(装饰类)：它也是抽象构建类的子类，用于给具体构建类添加方法 **它维护一个指向抽象构建对象的引用，通过该引用可以调用装饰之前构建对象的方法** ，并通过其子类扩展该方法，已达到装饰的目的。

ConcreteDecorator(具体装饰类):它是抽象装饰类的子类，负责给构建类添加新的方法。每一个具体的装饰类都定义了一个具体的行为。
###装饰模式的优缺点及使用场景
<br>
**优点**：

1.对于扩张一个对象的功能，装饰模式比继承模式更加灵活，不会导致类的数量急剧增加。<br>
2.可以通过一种动态的方式扩张一个类的功能，同过配置文件可以在运行时进行选择，不同的装饰类。<br>
3.可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合可以创造不同的行为的组合。<br><br><br>
**缺点**：

1.在使用装饰模式的时候进行系统设计时会产生很多小对象，这些对象的区别在于他们之间相互连接的方式有所不同，而不是他们的类或者属性值有所不同，大量小对象势必产生一大部分的系统资源开销。影响系统性能。<br>
2.装饰模式是一种比继承更加灵活的解决方案。但同时，也意味着比继承更加容易出错，更加难排长。对于多层装饰的对象，需要逐级排查，较为繁琐。
**<br><br><br>
使用场景**：

在不影响其他对象的情况下以动态的，透明的方式给单个对象添加职责。
不能用继承进行扩张的时候。
