###                                                                        简单工厂模式

---

**概述**：简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。

该模式中包含的角色及其职责

**工厂（Creator）角色**

简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。

**抽象产品（Product）角色**

简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。

**具体产品（Concrete Product）角色**

是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。



**简单工厂的类图关系**

![image](https://github.com/technical-exchange/design-mode/blob/dev/src/main/resources/static/images/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png)



**优点**

工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个[软件体系结构](https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)的优化。

**缺点**

违背了程序设计的开闭原则，由于工厂类集中了所有实例的创建逻辑，违反了[高内聚](https://baike.baidu.com/item/%E9%AB%98%E5%86%85%E8%81%9A)责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。

当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；

这些缺点在[工厂方法模式](https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F)中得到了一定的克服。

**使用场景**

工厂类负责创建的对象比较少；

客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；

由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。

